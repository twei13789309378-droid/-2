<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>莫奈花园：光影变幻 (Monet's Garden - Interactive WebGL)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { width: 100%; height: 100%; position: absolute; z-index: 1; }
        #video-input { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; pointer-events: none; z-index: 10; transition: opacity 0.5s; text-align: center; }
        .loading-sub { font-size: 14px; opacity: 0.7; margin-top: 10px; }
    </style>
    <!-- Import Maps for Three.js and Addons -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- MediaPipe & Tweakpane -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweakpane@4.0.1/dist/tweakpane.min.js"></script>
</head>
<body>

    <div id="loading">
        正在初始化莫奈花园...<br>
        <span class="loading-sub">请允许摄像头权限以进行手势交互<br>首次加载模型需要几秒钟</span>
    </div>
    <video id="video-input"></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // 1. 配置与全局状态 (Configuration & State)
        // ==========================================
        const CONFIG = {
            particleCount: 60000, // 粒子数量，可根据性能调整
            particleSize: 2.0,
            transitionSpeed: 0.05, // 手势平滑系数
            
            // 莫奈配色 - 白天 (暖色, 印象派日出)
            dayColors: [
                new THREE.Color('#FFD700'), // 金黄
                new THREE.Color('#FF8C00'), // 橙红
                new THREE.Color('#98FB98'), // 嫩绿
                new THREE.Color('#FF69B4')  // 粉红 (睡莲)
            ],
            
            // 莫奈配色 - 夜晚 (冷色, 睡莲池倒影)
            nightColors: [
                new THREE.Color('#00CED1'), // 青色
                new THREE.Color('#4B0082'), // 深紫
                new THREE.Color('#191970'), // 午夜蓝
                new THREE.Color('#E0FFFF')  // 银白月光
            ],

            bloomStrengthDay: 1.5,
            bloomStrengthNight: 0.8,
            bloomRadius: 0.8,
            bloomThreshold: 0.1
        };

        const STATE = {
            handOpenness: 0, // 0 = 握拳(夜), 1 = 张开(昼)
            targetHandOpenness: 0,
            currentPattern: 'waterLilies', // 当前形态
            time: 0
        };

        // ==========================================
        // 2. 着色器代码 (GLSL Shaders)
        // ==========================================
        
        // 顶点着色器：处理粒子位置变换、大小动态
        const vertexShader = `
            uniform float uTime;
            uniform float uOpenness; // 0.0 - 1.0 (夜 - 昼)
            uniform float uSize;
            uniform vec3 uTargetConfig; // 用于控制形态变换的额外参数

            attribute vec3 positionTarget; // 目标形态的位置
            attribute float sizeRandom;
            attribute vec3 colorDay;
            attribute vec3 colorNight;

            varying vec3 vColor;
            varying float vAlpha;

            // 简单的伪随机函数
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            // 噪声函数用于自然流动
            float noise(vec3 p) {
                return sin(p.x * 0.5 + uTime) * cos(p.z * 0.5 + uTime) * 0.5;
            }

            void main() {
                // 1. 位置混合 (Morphing)
                // 在当前位置(position)和目标位置(positionTarget)之间暂时不直接做Buffer混合，
                // 而是我们假设 attribute position 已经是计算好的特定形态，
                // 这里的动态主要体现在 "生气(Day)" vs "静谧(Night)" 的微动。

                vec3 pos = position;

                // --- 动态效果 ---
                
                // 白天：粒子向上浮动，充满活力 (勃发)
                float dayActivity = uOpenness * 2.0;
                vec3 dayOffset = vec3(
                    cos(uTime * 2.0 + pos.y) * 0.2,
                    sin(uTime * 3.0 + pos.x) * 0.5 + noise(pos) * 2.0,
                    sin(uTime * 2.0 + pos.z) * 0.2
                ) * dayActivity;

                // 夜晚：粒子相对静止，像水面反光或星空
                float nightActivity = (1.0 - uOpenness) * 0.5;
                vec3 nightOffset = vec3(
                    sin(uTime * 0.5 + pos.y) * 0.05,
                    cos(uTime * 0.5 + pos.x) * 0.05,
                    0.0
                ) * nightActivity;

                vec3 finalPos = pos + mix(nightOffset, dayOffset, uOpenness);

                // --- 大小变化 ---
                // 白天：粒子膨胀，光晕感强
                // 夜晚：粒子细小，锐利
                float currentSize = uSize * sizeRandom;
                currentSize *= mix(0.8, 2.5, uOpenness); // 白天变大
                
                // 透视投影
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // 基于深度的点大小衰减
                gl_PointSize = currentSize * (300.0 / -mvPosition.z);

                // --- 颜色混合 ---
                vColor = mix(colorNight, colorDay, uOpenness);
                
                // 透明度变化：夜晚略微透明，增加幽深感
                vAlpha = mix(0.7, 1.0, uOpenness);
            }
        `;

        // 片元着色器：处理粒子纹理、形状裁切
        const fragmentShader = `
            uniform float uOpenness;
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                // 粒子纹理生成
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);

                // 圆形遮罩
                if (dist > 0.5) discard;

                // --- 边缘软硬度 ---
                // 白天：边缘羽化，发光感 (Soft Glow)
                // 夜晚：边缘清晰 (Sharp Moon)
                float softEdge = mix(0.05, 0.4, uOpenness); 
                float alpha = smoothstep(0.5, 0.5 - softEdge, dist);

                // 核心亮度增强 (模拟高光)
                vec3 finalColor = vColor;
                if(dist < 0.1) {
                    finalColor += vec3(0.2) * uOpenness; // 白天中心过曝效果
                }

                gl_FragColor = vec4(finalColor, alpha * vAlpha);
            }
        `;

        // ==========================================
        // 3. Three.js 场景构建 (Scene Setup)
        // ==========================================
        
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 增加一点环境雾，夜晚更浓
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 40);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 性能优化
        container.appendChild(renderer.domElement);

        // --- 后处理 (Post Processing) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrengthNight; // 初始为夜
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // ==========================================
        // 4. 粒子系统核心 (Particle System)
        // ==========================================

        let particleSystem, geometry, material;

        function initParticles() {
            geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const sizes = [];
            const colorsDay = [];
            const colorsNight = [];

            // 初始化位置（由于是BufferAttribute，初始位置先设为0，稍后由形状函数填充）
            // 这里预分配最大内存
            for (let i = 0; i < CONFIG.particleCount; i++) {
                positions.push(0, 0, 0);
                sizes.push(Math.random());

                // 随机分配颜色
                const cDay = CONFIG.dayColors[Math.floor(Math.random() * CONFIG.dayColors.length)];
                const cNight = CONFIG.nightColors[Math.floor(Math.random() * CONFIG.nightColors.length)];

                colorsDay.push(cDay.r, cDay.g, cDay.b);
                colorsNight.push(cNight.r, cNight.g, cNight.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('sizeRandom', new THREE.Float32BufferAttribute(sizes, 1));
            geometry.setAttribute('colorDay', new THREE.Float32BufferAttribute(colorsDay, 3));
            geometry.setAttribute('colorNight', new THREE.Float32BufferAttribute(colorsNight, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uOpenness: { value: 0 },
                    uSize: { value: CONFIG.particleSize },
                    uTargetConfig: { value: new THREE.Vector3(0, 0, 0) }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            // 初始形态：睡莲池
            transformToPattern('waterLilies');
        }

        // --- 形态生成算法 (Generative Patterns) ---
        
        // 辅助函数：球坐标转笛卡尔
        function getSpherePoint(r, theta, phi) {
            return new THREE.Vector3(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.cos(phi),
                r * Math.sin(phi) * Math.sin(theta)
            );
        }

        function transformToPattern(patternName) {
            STATE.currentPattern = patternName;
            const positions = geometry.attributes.position.array;
            const count = CONFIG.particleCount;

            // 临时向量
            const vec = new THREE.Vector3();

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                let x, y, z;
                const ratio = i / count;

                if (patternName === 'waterLilies') {
                    // 睡莲池：平面分布 + 簇状睡莲
                    // 80% 粒子作为水面，20% 组成睡莲
                    if (Math.random() > 0.2) {
                        // 水面 (椭圆分布)
                        const angle = Math.random() * Math.PI * 2;
                        const radius = Math.sqrt(Math.random()) * 30;
                        x = Math.cos(angle) * radius;
                        z = Math.sin(angle) * radius;
                        y = (Math.sin(x * 0.2) + Math.cos(z * 0.1)) * 0.5; // 波浪起伏
                    } else {
                        // 睡莲 (若干个中心点)
                        const lilyCenters = [{x: 10, z: 5}, {x: -10, z: -10}, {x: 5, z: -15}];
                        const center = lilyCenters[Math.floor(Math.random() * lilyCenters.length)];
                        const angle = Math.random() * Math.PI * 2;
                        const r = Math.random() * 3; // 睡莲半径
                        // 花瓣向上翘起
                        x = center.x + Math.cos(angle) * r;
                        z = center.z + Math.sin(angle) * r;
                        y = 1.0 + r * r * 0.1; 
                    }
                } 
                else if (patternName === 'japaneseBridge') {
                    // 日式拱桥
                    // 桥身：拱形
                    if (i < count * 0.7) {
                        const t = (i / (count * 0.7)) * 2 - 1; // -1 to 1
                        const width = 4 + Math.random() * 2;
                        x = t * 20;
                        z = (Math.random() - 0.5) * width;
                        // 抛物线方程 y = -x^2
                        y = 10 - (x * x) * 0.04;
                        if (y < 0) y = 0;
                    } else {
                        // 桥下的倒影或流水
                        x = (Math.random() - 0.5) * 50;
                        z = (Math.random() - 0.5) * 50;
                        y = -2 + Math.random();
                    }
                } 
                else if (patternName === 'weepingWillow') {
                    // 垂柳
                    // 树干和垂下的枝条
                    if (i < count * 0.1) {
                        // 树干
                        const h = Math.random() * 15;
                        const r = (15 - h) * 0.1;
                        const angle = Math.random() * Math.PI * 2;
                        x = Math.cos(angle) * r;
                        z = Math.sin(angle) * r;
                        y = h;
                    } else {
                        // 枝条 (Catmull-Rom like curves downwards)
                        const branchAngle = Math.random() * Math.PI * 2;
                        const startHeight = 12 + Math.random() * 4;
                        const radiusOut = 2 + Math.random() * 10;
                        const drop = Math.random() * 20;
                        
                        // 贝塞尔曲线模拟垂落
                        x = Math.cos(branchAngle) * radiusOut * (1 + drop*0.05);
                        z = Math.sin(branchAngle) * radiusOut * (1 + drop*0.05);
                        y = startHeight - drop;
                    }
                }

                // 更新 Buffer
                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;
            }

            geometry.attributes.position.needsUpdate = true;
        }

        // ==========================================
        // 5. MediaPipe 手势识别 (Computer Vision)
        // ==========================================
        
        const videoElement = document.getElementById('video-input');
        
        function onResults(results) {
            document.getElementById('loading').style.opacity = 0; // 隐藏 Loading

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 简单的开合检测算法：
                // 计算指尖(Tip)到手腕(Wrist - index 0)的平均距离
                // 拇指(4), 食指(8), 中指(12), 无名指(16), 小指(20)
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20];
                let totalDist = 0;

                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const d = Math.sqrt(
                        Math.pow(tip.x - wrist.x, 2) + 
                        Math.pow(tip.y - wrist.y, 2)
                    );
                    totalDist += d;
                });
                
                const avgDist = totalDist / 5;
                
                // 归一化：通常握拳 avgDist 约 0.15-0.2，张开约 0.4-0.5
                // 映射到 0 (夜/闭) - 1 (昼/开)
                let openVal = (avgDist - 0.2) / (0.4 - 0.2);
                openVal = Math.max(0, Math.min(1, openVal)); // Clamp

                STATE.targetHandOpenness = openVal;
            } else {
                // 如果没有手，慢慢回到夜晚模式（休息状态）
                STATE.targetHandOpenness = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // 摄像头处理
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

        // ==========================================
        // 6. UI 面板 (Tweakpane)
        // ==========================================
        
        const pane = new Tweakpane.Pane({ title: '控制面板 / Controls' });
        
        // 场景选择
        const patInput = pane.addBinding(STATE, 'currentPattern', {
            options: {
                '睡莲池 / Water Lilies': 'waterLilies',
                '日式桥 / Japanese Bridge': 'japaneseBridge',
                '垂柳小径 / Weeping Willow': 'weepingWillow',
            },
            label: '场景 Pattern'
        });
        patInput.on('change', (ev) => {
            transformToPattern(ev.value);
        });

        // 强制滑块 (方便没摄像头的用户调试)
        const debugFolder = pane.addFolder({ title: '调试 Debug (当无摄像头时)', expanded: false });
        debugFolder.addBinding(STATE, 'targetHandOpenness', { min: 0, max: 1, label: '开合模拟' });

        // Bloom 设置
        const bloomFolder = pane.addFolder({ title: '光影设置 Post-Process', expanded: false });
        bloomFolder.addBinding(CONFIG, 'bloomStrengthDay', { min: 0, max: 3, label: '日间辉光' });
        bloomFolder.addBinding(CONFIG, 'bloomStrengthNight', { min: 0, max: 3, label: '夜间辉光' });
        
        // 全屏
        const btn = pane.addButton({ title: '全屏 / Fullscreen' });
        btn.on('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        // ==========================================
        // 7. 渲染循环 (Animation Loop)
        // ==========================================
        
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            STATE.time += dt;

            // 1. 数据平滑 (Lerp)
            // 将当前的 openness 平滑过渡到 target
            STATE.handOpenness += (STATE.targetHandOpenness - STATE.handOpenness) * CONFIG.transitionSpeed;

            // 2. 更新 Uniforms
            if (material) {
                material.uniforms.uTime.value = STATE.time;
                material.uniforms.uOpenness.value = STATE.handOpenness;
            }

            // 3. 更新 Post-Processing 参数
            // 根据手势混合 Bloom 强度
            const currentStrength = THREE.MathUtils.lerp(
                CONFIG.bloomStrengthNight, 
                CONFIG.bloomStrengthDay, 
                STATE.handOpenness
            );
            bloomPass.strength = currentStrength;
            
            // 4. 摄像机微动 (增加电影感)
            const camTime = STATE.time * 0.2;
            camera.position.x = Math.sin(camTime) * 5;
            camera.lookAt(0, 2, 0);

            // 5. 渲染
            composer.render();
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // 启动
        initParticles();
        animate();

    </script>
</body>
</html>